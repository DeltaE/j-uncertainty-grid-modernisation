# -*- coding: utf-8 -*-
"""
Created: 2025-10-26
Author: luisfernando (edited)

Purpose
-------
Generate scenario dictionaries ("MIXES") using two DOE engines:
Latin Hypercube (LHS) and Sobol. Scenario "0" is fixed (as provided);
scenarios "1" .. "N_CASES" are generated by LHS and Sobol respectively.

Outputs
-------
- mixes_lhs.json, mixes_sobol.json  (JSON dicts keyed by "0","1",...,"N")
- mixes_compare_long.csv            (flattened long table w/ method column)
- lhs_vs_sobol_summary.csv          (simple per-field summary stats)
- compare_unitcube_pairs.png        (optional sanity plot on unit cube)
- overlay_ev_vs_pv.png              (optional transformed overlay plot)

Notes
-----
- Only fields present in MIXES are varied.
- Sobol requires SciPy's qmc; LHS works without SciPy.
- Set N_CASES (placeholder) based on runtime: ~230 seconds/scenario.
"""

import json
import math
import numpy as np
import pandas as pd

# Matplotlib for headless environments
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt

# ---------- Optional SciPy QMC (Sobol/LHS engines) ----------
try:
    from scipy.stats import qmc  # Sobol + LatinHypercube
    _HAS_SCIPY_QMC = True
except Exception:
    _HAS_SCIPY_QMC = False

# ============================ CONFIG ============================

# >>>>>>>>>>>>>>>>>>>>> EDIT THIS PLACEHOLDER <<<<<<<<<<<<<<<<<<<<
N_CASES      = 10  # <-- PLACEHOLDER. Number of variable scenarios (1..N). "0" stays fixed.

BASE_SEED    = 123          # reproducibility for sampling engines
SEED0_FIXED  = 555          # seed for case "0"
SEED_STEP    = 222          # seeds follow 555, 777, 999, ... (seed = SEED0_FIXED + SEED_STEP*case_id)

# Output files
OUT_JSON_LHS   = "mixes_lhs.json"
OUT_JSON_SOBOL = "mixes_sobol.json"
OUT_LONG       = "mixes_compare_long.csv"
OUT_SUMMARY    = "lhs_vs_sobol_summary.csv"

# Plots (optional)
FIG_UNITCUBE   = "compare_unitcube_pairs.png"
FIG_OVERLAY    = "overlay_ev_vs_pv.png"

# -------- Bounds for fields that vary (percent/fractions in [0,1]) --------
# Tune these to your project. The examples you gave (0.10/0.35 EV, 0.05/0.12 storage, 0.05/0.10 PV)
# fall comfortably within the default ranges below.
BOUNDS = {
    "ev_perc":           (0.05, 0.80),  # share of customers w/ EVs
    "ev_lvl2_perc":      (0.5, 0.99),  # share of EVs with Level-2 charging
    "storage_perc_3ph":  (0.00, 0.20),  # share of 3-phase customers w/ storage
    "pv_perc_3ph":       (0.00, 0.20),  # share of 3-phase customers w/ PV
}

# EV split: keep fixed 50-50 by default (matches "if omitted, defaults to 50-50")
EV_SPLIT_FIXED = False # True # (if true, everything remains at 50%-50%).
EV_SPLIT_BOUNDS = (0.20, 0.80)  # only used if EV_SPLIT_FIXED=False; controlled in [lo, hi]

# Disjoint sets flag; set per scenario (constant here, but configurable)
DISJOINT_SETS_DEFAULT = False #True

# ====================== Fixed scenario "0" ======================
# Exact structure as requested
FIXED_CASE0 = {
    "shares": {"baseline": 1.0, "dm": 0.0, "un": 0.0},
    "heating_seed": SEED0_FIXED,
    "ev_perc": 0.10, "ev_lvl2_perc": 0.80, "ev_seed": SEED0_FIXED,
    "storage_perc_3ph": 0.05, "storage_seed": SEED0_FIXED,
    "pv_perc_3ph": 0.05,      "pv_seed": SEED0_FIXED,
    "disjoint_sets": False,
    # NEW: if omitted, consumer defaults to 50-50; we include it explicitly.
    "ev_split": {"controlled": 0.5, "uncontrolled": 0.5},
}

# ====================== Minimal DOE helpers =====================

def _plot_param_histograms(df_lhs, df_sobol, outpath, vars_to_plot):
    """
    For each variable in vars_to_plot, plot LHS vs Sobol histograms on the same axes.
    """
    n = len(vars_to_plot)
    ncols = 2
    nrows = int(math.ceil(n / ncols))
    fig, axes = plt.subplots(nrows=nrows, ncols=ncols,
                             figsize=(10, 3.0 * nrows),
                             constrained_layout=True)
    axes = np.array(axes).reshape(nrows, ncols)

    for idx, var in enumerate(vars_to_plot):
        r = idx // ncols
        c = idx % ncols
        ax = axes[r, c]
        ax.hist(df_lhs[var], bins=20, alpha=0.5, label="LHS", density=True)
        ax.hist(df_sobol[var], bins=20, alpha=0.5, label="Sobol", density=True, histtype="step")
        ax.set_title(var)
        ax.legend(loc="best")

    # Hide any empty subplots
    for j in range(len(vars_to_plot), nrows * ncols):
        r = j // ncols
        c = j % ncols
        axes[r, c].axis("off")

    fig.suptitle("Parameter distributions: LHS vs Sobol", y=1.02, fontsize=12)
    fig.savefig(outpath, dpi=150, bbox_inches="tight")
    plt.close(fig)

def _lhs_unit(n, d, seed=None):
    """Unit-cube LHS (SciPy if available, else pure-NumPy)."""
    if _HAS_SCIPY_QMC:
        engine = qmc.LatinHypercube(d=d, seed=seed)
        return engine.random(n)
    # Pure-NumPy LHS with jitter in strata
    rng = np.random.default_rng(seed)
    cut = np.linspace(0.0, 1.0, n + 1)
    a, b = cut[:-1], cut[1:]
    H = np.zeros((n, d))
    for j in range(d):
        u = rng.random(n)
        H[:, j] = rng.permutation(u * (b - a) + a)
    return H

def _sobol_unit(n, d, seed=None, scramble=True):
    """Unit-cube Sobol (SciPy required)."""
    if not _HAS_SCIPY_QMC:
        raise RuntimeError("Sobol sampling requires SciPy (scipy.stats.qmc).")
    m = math.ceil(math.log2(max(2, n)))  # draw power-of-two, then truncate
    engine = qmc.Sobol(d=d, scramble=scramble, seed=seed)
    U = engine.random_base2(m=m)
    return U[:n, :]

# ========= Transforms from U[0,1]^k to MIXES fields only ========

def _dirichlet_from_uniform(u_mat):
    """
    Map U in (0,1)^{n×3} to Dirichlet(1,1,1) on the 3-simplex via Gamma(1,1).
    Stable even if u hits 0/1 after clipping.
    """
    U = np.clip(u_mat, 1e-12, 1-1e-12)
    G = -np.log(U)  # Exp(1) = Gamma(k=1, theta=1)
    W = G / G.sum(axis=1, keepdims=True)
    return W  # columns correspond to ["baseline","dm","un"]

def _linmap01(u, lo, hi):
    return lo + u * (hi - lo)

def _make_scenario_dicts_from_unit(U, case_ids, fixed_case0, bounds, ev_split_fixed=True, ev_split_bounds=(0.2,0.8)):
    """
    Convert unit-cube rows into MIXES dicts for the given case_ids (ints >=1).
    Does NOT include case "0"; caller should add fixed_case0 separately.
    Dimensions of U:
      - 3 columns for shares
      - 4 columns for {ev_perc, ev_lvl2_perc, storage_perc_3ph, pv_perc_3ph}
      - +1 column if ev_split is sampled (controlled share); uncontrolled = 1 - controlled
    """
    mixes = {}
    n = len(case_ids)
    col = 0

    # shares
    shares = _dirichlet_from_uniform(U[:, col:col+3]); col += 3
    baseline = shares[:, 0]; dm = shares[:, 1]; un = shares[:, 2]

    # main fractions
    ev_perc          = _linmap01(U[:, col+0], *bounds["ev_perc"])
    ev_lvl2_perc     = _linmap01(U[:, col+1], *bounds["ev_lvl2_perc"])
    storage_perc_3ph = _linmap01(U[:, col+2], *bounds["storage_perc_3ph"])
    pv_perc_3ph      = _linmap01(U[:, col+3], *bounds["pv_perc_3ph"])
    col += 4

    # ev_split
    if ev_split_fixed:
        ev_ctrl = np.full(n, 0.5)
    else:
        lo, hi = ev_split_bounds
        ev_ctrl = _linmap01(U[:, col], lo, hi)
        col += 1
    ev_unctrl = 1.0 - ev_ctrl

    # seeds: deterministic, same within scenario, independent of DOE engine
    def seed_for_case(case_id):
        return int(SEED0_FIXED + SEED_STEP * case_id)

    for idx, case_id in enumerate(case_ids):
        s = seed_for_case(case_id)
        mixes[str(case_id)] = {
            "shares": {
                "baseline": float(baseline[idx]),
                "dm":       float(dm[idx]),
                "un":       float(un[idx]),
            },
            "heating_seed": s,
            "ev_perc":          float(ev_perc[idx]),
            "ev_lvl2_perc":     float(ev_lvl2_perc[idx]),
            "ev_seed":          s,
            "storage_perc_3ph": float(storage_perc_3ph[idx]),
            "storage_seed":     s,
            "pv_perc_3ph":      float(pv_perc_3ph[idx]),
            "pv_seed":          s,
            "disjoint_sets":    DISJOINT_SETS_DEFAULT,
            "ev_split": {
                "controlled":  float(ev_ctrl[idx]),
                "uncontrolled":float(ev_unctrl[idx]),
            },
        }
    return mixes

def _flatten_mix_dict(mix_id, mix, method):
    """Flatten one MIXES entry to a 1-row dict for CSV."""
    row = {
        "id": mix_id,
        "method": method,
        "shares_baseline": mix["shares"]["baseline"],
        "shares_dm": mix["shares"]["dm"],
        "shares_un": mix["shares"]["un"],
        "ev_perc": mix["ev_perc"],
        "ev_lvl2_perc": mix["ev_lvl2_perc"],
        "storage_perc_3ph": mix["storage_perc_3ph"],
        "pv_perc_3ph": mix["pv_perc_3ph"],
        "ev_split_controlled": mix["ev_split"]["controlled"],
        "ev_split_uncontrolled": mix["ev_split"]["uncontrolled"],
        "heating_seed": mix["heating_seed"],
        "ev_seed": mix["ev_seed"],
        "storage_seed": mix["storage_seed"],
        "pv_seed": mix["pv_seed"],
        "disjoint_sets": mix["disjoint_sets"],
    }
    return row

def _summarize(df, method_name):
    """Return summary stats per numeric column with a method tag."""
    num = df.select_dtypes(include=[np.number])
    q = num.quantile([0.05, 0.25, 0.50, 0.75, 0.95]).T
    q.columns = ["q05","q25","q50","q75","q95"]
    s = pd.DataFrame({
        "mean": num.mean(),
        "std":  num.std(ddof=1),
        "min":  num.min(),
        "max":  num.max(),
    })
    out = s.join(q)
    out.insert(0, "variable", out.index)
    out.insert(0, "method", method_name)
    out.reset_index(drop=True, inplace=True)
    return out

# ------------------------- PLOTTING -----------------------------

def _plot_unitcube_side_by_side(U_lhs, U_sobol, outpath, max_pairs=3, title_left="LHS", title_right="Sobol"):
    """
    Show U[0,1] sampling spaces for selected 2D projections, side by side.
    Pairs built as (0,1), (2,3), ...
    """
    d = U_lhs.shape[1]
    pairs = []
    for i in range(0, min(d, 2*max_pairs), 2):
        if i+1 < d: pairs.append((i, i+1))
    if not pairs and d >= 2:
        pairs = [(0, 1)]
    nrows = len(pairs)
    fig, axes = plt.subplots(nrows=nrows, ncols=2, figsize=(10, 2.6*nrows), constrained_layout=True)
    if nrows == 1: axes = np.array([axes])
    for r, (i, j) in enumerate(pairs):
        axL = axes[r, 0]; axR = axes[r, 1]
        axL.scatter(U_lhs[:, i], U_lhs[:, j], s=8, alpha=0.6)
        axR.scatter(U_sobol[:, i], U_sobol[:, j], s=8, alpha=0.6)
        for ax in (axL, axR):
            ax.set_xlim(0,1); ax.set_ylim(0,1)
            ax.set_xlabel(f"u[{i}]"); ax.set_ylabel(f"u[{j}]")
        if r == 0:
            axL.set_title(title_left); axR.set_title(title_right)
    fig.suptitle("Unit-cube projections: LHS (left) vs Sobol (right)", y=1.02, fontsize=12)
    fig.savefig(outpath, dpi=150, bbox_inches="tight"); plt.close(fig)

def _plot_overlay_ev_vs_pv(df_lhs, df_sobol, outpath):
    """Overlay EV% vs PV% for LHS vs Sobol (quick sanity check on transformed space)."""
    fig, ax = plt.subplots(figsize=(6.5, 5.0))
    ax.scatter(df_lhs["ev_perc"], df_lhs["pv_perc_3ph"], s=12, alpha=0.5, label="LHS", marker="o")
    ax.scatter(df_sobol["ev_perc"], df_sobol["pv_perc_3ph"], s=12, alpha=0.5, label="Sobol", marker="x")
    ax.set_xlabel("ev_perc"); ax.set_ylabel("pv_perc_3ph")
    ax.legend(loc="best")
    ax.set_title("Overlay: ev_perc vs pv_perc_3ph")
    fig.savefig(outpath, dpi=150, bbox_inches="tight"); plt.close(fig)

# =============================== RUN ===============================

if __name__ == "__main__":
    # Dimension of the unit cube we need:
    # 3 (shares) + 4 (ev, ev_lvl2, storage, pv) + (1 if ev_split is sampled)
    d = 3 + 4 + (0 if EV_SPLIT_FIXED else 1)
    var_names = [f"u{i}" for i in range(d)]  # for plotting labels

    # Build unit-cube samples for cases 1..N
    case_ids = list(range(1, N_CASES + 1))

    print(f"[Config] N_CASES={N_CASES} (case '0' is fixed).")
    print(f"[Timing hint] ~230 s/scenario → ≈ {int((N_CASES+1)*2*230/60)} minutes for both methods incl. case 0.")

    # -------- LHS --------
    print(f"[LHS] n={len(case_ids)}, d={d}")
    U_lhs = _lhs_unit(len(case_ids), d, seed=BASE_SEED)
    mixes_lhs = {"0": FIXED_CASE0.copy()}
    mixes_lhs.update(_make_scenario_dicts_from_unit(
        U_lhs, case_ids, FIXED_CASE0, BOUNDS, EV_SPLIT_FIXED, EV_SPLIT_BOUNDS
    ))

    # -------- Sobol --------
    if not _HAS_SCIPY_QMC:
        raise SystemExit("SciPy qmc not available; install scipy>=1.7 to generate Sobol design.")
    print(f"[Sobol] n={len(case_ids)}, d={d}")
    U_sobol = _sobol_unit(len(case_ids), d, seed=BASE_SEED, scramble=True)
    mixes_sobol = {"0": FIXED_CASE0.copy()}
    mixes_sobol.update(_make_scenario_dicts_from_unit(
        U_sobol, case_ids, FIXED_CASE0, BOUNDS, EV_SPLIT_FIXED, EV_SPLIT_BOUNDS
    ))

    # -------- Write JSON dictionaries --------
    with open(OUT_JSON_LHS, "w", encoding="utf-8") as f:
        json.dump(mixes_lhs, f, indent=2)
    print(f" -> wrote {OUT_JSON_LHS} ({len(mixes_lhs)} scenarios incl. '0')")

    with open(OUT_JSON_SOBOL, "w", encoding="utf-8") as f:
        json.dump(mixes_sobol, f, indent=2)
    print(f" -> wrote {OUT_JSON_SOBOL} ({len(mixes_sobol)} scenarios incl. '0')")

    # -------- Build / save combined long CSV for quick QA --------
    def to_long(mixes, method):
        rows = []
        for k, v in mixes.items():
            rows.append(_flatten_mix_dict(k, v, method))
        return pd.DataFrame(rows)

    df_lhs = to_long(mixes_lhs, "LHS").sort_values(by="id", key=lambda s: s.astype(int)).reset_index(drop=True)
    df_sob  = to_long(mixes_sobol, "Sobol").sort_values(by="id", key=lambda s: s.astype(int)).reset_index(drop=True)

    df_long = pd.concat([df_lhs, df_sob], axis=0, ignore_index=True)
    df_long.to_csv(OUT_LONG, index=False)
    print(f" -> wrote {OUT_LONG} {df_long.shape}")

    # -------- Simple summaries (per method) --------
    summ_lhs = _summarize(df_lhs.drop(columns=["id","method"]),   "LHS")
    summ_sob = _summarize(df_sob.drop(columns=["id","method"]),   "Sobol")
    df_summary = pd.concat([summ_lhs, summ_sob], axis=0, ignore_index=True)
    df_summary.to_csv(OUT_SUMMARY, index=False)
    print(f" -> wrote {OUT_SUMMARY} {df_summary.shape}")

    # ------------------------ PLOTS (optional) -------------------
    print("[Plots] generating side-by-side unit-cube projections…")
    _plot_unitcube_side_by_side(U_lhs, U_sobol, FIG_UNITCUBE, max_pairs=3)
    print(f" -> wrote {FIG_UNITCUBE}")

    print("[Plots] generating overlay of EV vs PV fractions…")
    _plot_overlay_ev_vs_pv(df_lhs, df_sob, FIG_OVERLAY)
    print(f" -> wrote {FIG_OVERLAY}")

    print("[Plots] generating parameter histograms…")
    _param_vars = [
        "shares_baseline",
        "shares_dm",
        "shares_un",
        "ev_perc",
        "ev_lvl2_perc",
        "storage_perc_3ph",
        "pv_perc_3ph",
        "ev_split_controlled",
    ]
    _plot_param_histograms(df_lhs, df_sob, "param_histograms_lhs_vs_sobol.png", _param_vars)
    print(" -> wrote param_histograms_lhs_vs_sobol.png")

    print("Done.")

